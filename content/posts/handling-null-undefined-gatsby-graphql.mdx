---
title: Handling null and undefined in Gatsby GraphQL queries
author: Eric Howey
authorLink: https://twitter.com/erchwy
tags: [Gatsby]
date: 2020-02-20
featuredImage: ../post-assets/featured-null-undefined-graphql.jpg
draft: true
---

Have you ever seen something like this when working on a Gatsby site?

```sh
ERROR #85925  GRAPHQL

There was an error in your GraphQL query:

Cannot return null for non-nullable field MdxCatalystPost.timeToRead.
```

This just happened to me, but what happened and why? Let's break it down.

Note that GraphQL schema customization for Gatsby is done in the `gatsby-node.js` file. This topic is covered in the main Gatsby Docs under [schema customization](https://www.gatsbyjs.org/docs/schema-customization/).

- `timeToRead` is a GraphQL field for my blog posts, it is provided by the [reading time plugin](https://www.gatsbyjs.org/packages/gatsby-remark-reading-time/).
- In my GraphQL schema I defined this field as 'non-nullable', it looks like this; `timeToRead: Int!`. This tells Gatsby two important things about this field; that it will be a number value and also that it is non-nullable because of the exclamation point. It needs to have a value assigned to it, in this case an integer value.
- When I saved the post with only frontmatter there was no markdown content for the reading time plugin to measure, so it returned just null. Which isn't technically wrong.
- When Gatsby was generating the GraphQL fields it saw that `timeToRead` was null and threw the above error, basically telling me 'Hey! Didn't you tell me this couldn't be null!? Ahhh! Error!'

So how do we fix this? The quick answer in this case is to just put a bit of text in the blog post, and boom our error goes away everything works because the field is no longer null. For a more robust fix all I just need to remove the exclamation point, `timeToRead: Int`. Now the field can be null, but is required to be a number value.

This was a pretty straightforward example, what happens when we need default values and a more complex data structure? The rest of this post will work through an example handling a `subMenu` array inside of `gatsby-config.js`. This was a real problem I ran into when working on implementing drop down menus in Gatsby.

## Schema Inference

By default Gatsby tries to infer the GraphQL schema for your project, and to be honest it does a really great job of this in smaller, less complicated sites. However once you start dealing with complicated data structures and larger sites it is more efficient to define the GraphQL schema for Gatsby. The pattern I have noticed with Gatsby is that if a field is _sometimes_ present and it has runs into problems with the schema inference.

In this example the `menuLinks` array in `gatsby-config.js` will _sometimes_ have a drop-down menu, another array called `subMenu`. If a field is going to only _sometimes_ be present in your data then this is when you need to explicitly tell Gatsby to create the fields using the schema customization API.

Here is the `gatsby-config.js` file structure we will be working with:

```js
module.exports = {
  siteMetadata: {
    title: `Scheming Schemas!`,
    description: `Planning to take over the world!`,
    author: `Eric Howey`,
    menuLinks: [
      {
        name: `Page 1`,
        link: `/page-1`,
        type: `internal`, //internal or anchor
      },
      {
        name: `Page 2`,
        link: `/page-2`,
        type: `internal`, //internal or anchor
        subMenu: [
          {
            name: `Sub 1`,
            link: `/sub-1`,
            type: `internal`, //internal or anchor
          },
          {
            name: `Sub 2`,
            link: `/sub-2`,
            type: `internal`, //internal or anchor
          },
        ],
      },
    ],
  },
}
```

## Defining the fields

We need to use the [create types](https://www.gatsbyjs.org/docs/actions/#createTypes) API to tell Gatsby what fields it can expect in the `menuLinks` array.

```js
exports.createSchemaCustomization = ({ actions }) => {
  const { createTypes } = actions
  const typeDefs = `
    type Site implements Node {
      siteMetadata: SiteMetadata
    }
    type SiteMetadata {
      menuLinks: [MenuLinks]
    }
    type MenuLinks {
      name: String!
      link: String!
      subMenu: [SubMenu]
    }
    type SubMenu {
      name: String
      link: String
    }
  `
  createTypes(typeDefs)
}
```

When using this API the capitalization matters, and also note that I did not include `@dontInfer` to [opt out of type inference](https://www.gatsbyjs.org/docs/schema-customization/#opting-out-of-type-inference). I am letting Gatsby handle inferring all of the other fields in `siteMetadata` but I am explicitly telling it to create the `menuLinks` and `subMenu` fields.

## Allowing a field to be null or not

Notice the exclamation points beside some of the fields above? Remember that this tells Gatsby whether the field can be null or not. An exclamation point means the field _cannot_ be null. As I talked about in the introduction you have to think carefully about which fields are allowed to be null and which cannot. Otherwise you might run into errors like I did with `timeToRead`.

## Handling null fields and creating default values

If you don't want a field to be null, but instead want to have a default or placeholder value for the field you can do this with the [create field extension](https://www.gatsbyjs.org/docs/actions/#createFieldExtension) API. Let's add in a default value for our subMenu so instead of null it is just an empty array. This will become important because later we will map over the array.

```js
exports.createSchemaCustomization = ({ actions }) => {
  const { createFieldExtension, createTypes } = actions
  createFieldExtension({
    name: `defaultArray`,
    extend() {
      return {
        resolve(source, args, context, info) {
          if (source[info.fieldName] == null) {
            return []
          }
          return source[info.fieldName]
        },
      }
    },
  })
  const typeDefs = `
    type Site implements Node {
      siteMetadata: SiteMetadata
    }
    type SiteMetadata {
      menuLinks: [MenuLinks]
    }
    type MenuLinks {
      name: String!
      link: String!
      subMenu: [SubMenu] @defaultArray
    }
    type SubMenu {
      name: String
      link: String
    }
  `
  createTypes(typeDefs)
}
```

## Query Results

Now when the `menuLinks` array is queried we get the following data structure in return, notice the empty `subMenu` array on the page-1 link.

```json
"data": {
  "site": {
    "siteMetadata": {
      "menuLinks": [
        {
          "link": "/page-1",
          "name": "Page 1",
          "subMenu": []
        },
        {
          "link": "/page-2",
          "name": "Page 2",
          "subMenu": [
            {
              "link": "/sub-1",
              "name": "Sub 1"
            },
            {
              "link": "/sub-2",
              "name": "Sub 2"
            }
          ]
        }
      ]
    }
  }
}
```

## What this gives us

Because `subMenu` will always be an array we can now do some niftier things with the array
