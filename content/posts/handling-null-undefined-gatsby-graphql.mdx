---
title: Handling null and undefined in Gatsby GraphQL queries
author: Eric Howey
authorLink: https://twitter.com/erchwy
tags: [Gatsby]
date: 2020-02-20
featuredImage: ../post-assets/featured-null-undefined-graphql.jpg
draft: true
---

Have you ever seen something like this when working on a Gatsby site?

```sh
ERROR #85925  GRAPHQL

There was an error in your GraphQL query:

Cannot return null for non-nullable field MdxCatalystPost.timeToRead.
```

This just happened to me, but what happened and why? Let's break it down.

- `timeToRead` is a GraphQL field for my blog posts, it is provided by the [reading time plugin](https://www.gatsbyjs.org/packages/gatsby-remark-reading-time/).
- In my GraphQL schema I defined this field as 'non-nullable'; `timeToRead: Int!`. This tells Gatsby two important things about this field; that it will be a number value and also that it is non-nullable because of the exclamation point.
- When I saved the post with only frontmatter there was no markdown content for the reading time plugin to measure, so it returned null. Which isn't technically wrong.
- When Gatsby was generating the GraphQL fields it saw that `timeToRead` was null and threw the above error, effectively saying 'Hey! Didn't you tell me this couldn't be null!? Ahhh! Error!'

So how do we fix this? The quick answer is to just put a bit of text in the blog post, and boom our error goes away because it is no longer null. The real fix is to remove the exclamation point, `timeToRead: Int`. Now the field can be null, but is still required to be a number value.

This was a straightforward example, what happens when we need default values and a more complex data structure?

The rest of this post works through an example handling a `subMenu` array inside of `gatsby-config.js`. This was a real world coding problem I ran into when working on how to implement drop down menus in Gatsby.

## Schema Inference

Some quick background on schema inference.

By default Gatsby tries to infer the GraphQL schema for your project, and to be honest it does a really great job of this in smaller, less complicated sites. However once you start dealing with complicated data structures and larger sites it is more efficient and best practice to define the GraphQL schema for Gatsby. The pattern I have noticed with Gatsby is that if a field is _sometimes_ present and it will run into problems with the schema inference.

In this example the `menuLinks` array in `gatsby-config.js` will _sometimes_ have a drop-down menu, another array called `subMenu`. This is when you should explicitly tell Gatsby to create the fields using the [schema customization API](https://www.gatsbyjs.org/docs/schema-customization/) in `gatsby-node.js`.

## Example data structure

Here is the `gatsby-config.js` data structure we will be working with through in this example:

```js
module.exports = {
  siteMetadata: {
    title: `Scheming Schemas!`,
    description: `Planning to take over the world!`,
    author: `Eric Howey`,
    menuLinks: [
      {
        name: `Page 1`,
        link: `/page-1`,
        type: `internal`, //internal or anchor
      },
      {
        name: `Page 2`,
        link: `/page-2`,
        type: `internal`, //internal or anchor
        subMenu: [
          {
            name: `Sub 1`,
            link: `/sub-1`,
            type: `internal`, //internal or anchor
          },
          {
            name: `Sub 2`,
            link: `/sub-2`,
            type: `internal`, //internal or anchor
          },
        ],
      },
    ],
  },
}
```

## Defining the fields

We need to use the [create types](https://www.gatsbyjs.org/docs/actions/#createTypes) API to tell Gatsby what fields it can expect in the `menuLinks` array. If we just let Gatsby infer the field it would get it wrong.

```js
exports.createSchemaCustomization = ({ actions }) => {
  const { createTypes } = actions
  const typeDefs = `
    type Site implements Node {
      siteMetadata: SiteMetadata
    }
    type SiteMetadata {
      menuLinks: [MenuLinks]
    }
    type MenuLinks {
      name: String!
      link: String!
      subMenu: [SubMenu]
    }
    type SubMenu {
      name: String
      link: String
    }
  `
  createTypes(typeDefs)
}
```

When using this API the capitalization matters, and also note that I did not include `@dontInfer` to [opt out of type inference](https://www.gatsbyjs.org/docs/schema-customization/#opting-out-of-type-inference). I am letting Gatsby handle inferring all of the other fields in `siteMetadata` but I am explicitly telling it to create the `menuLinks` and `subMenu` fields.

## Allowing a field to be null or not

Notice the exclamation points beside some of the fields above? Remember that this tells Gatsby whether the field can be null or not. An exclamation point means the field _cannot_ be null. As I talked about in the introduction you have to think carefully about which fields are allowed to be null and which cannot. Otherwise you might run into errors like I did with `timeToRead` at the start.

## Handling null fields and creating default values

If you don't want a field to be null, but instead want to have a default or placeholder value for the field you can do this with the [create field extension](https://www.gatsbyjs.org/docs/actions/#createFieldExtension) API. Let's add in a default value for our subMenu so instead of null it is just an empty array. This will become important because later when we want to map the array.

```js
exports.createSchemaCustomization = ({ actions }) => {
  const { createFieldExtension, createTypes } = actions
  createFieldExtension({
    name: `defaultArray`,
    extend() {
      return {
        resolve(source, args, context, info) {
          if (source[info.fieldName] == null) {
            return []
          }
          return source[info.fieldName]
        },
      }
    },
  })
  const typeDefs = `
    type Site implements Node {
      siteMetadata: SiteMetadata
    }
    type SiteMetadata {
      menuLinks: [MenuLinks]
    }
    type MenuLinks {
      name: String!
      link: String!
      subMenu: [SubMenu] @defaultArray
    }
    type SubMenu {
      name: String
      link: String
    }
  `
  createTypes(typeDefs)
}
```

## Query Results

Now when the `menuLinks` array is queried with GraphQL we get the following data structure in return, notice the empty `subMenu` array on the page-1 link.

```json
"data": {
  "site": {
    "siteMetadata": {
      "menuLinks": [
        {
          "link": "/page-1",
          "name": "Page 1",
          "subMenu": []
        },
        {
          "link": "/page-2",
          "name": "Page 2",
          "subMenu": [
            {
              "link": "/sub-1",
              "name": "Sub 1"
            },
            {
              "link": "/sub-2",
              "name": "Sub 2"
            }
          ]
        }
      ]
    }
  }
}
```

## Now what?

We have created a dependable data structure that we can trust. Now you are free to use common javascript and React patterns, like mapping over an array to create your menus. Notice that you can check an arrays length and skip empty arrays, only mapping over the actual sub menus.

```jsx
<ul>
  {menuLinks.map(link => (
    <li key={link.name}>
      <a href={link.link}>{link.name}</a>
      {link.subMenu && link.subMenu.length > 0 ? (
        <ul>
          {link.subMenu.map(subLink => (
            <li key={subLink.name}>
              <a href={subLink.link}>{subLink.name}</a>
            </li>
          ))}
        </ul>
      ) : null}
    </li>
  ))}
</ul>
```
